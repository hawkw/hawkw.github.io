---
layout: post
title:  "A Layer-Based Text Editor"
categories: ideas, tools
---


#### Update (03/27/2015)

Since writing this blog post, I have put together a brief presentation on this topic, including some user-interface wireframes. The presentation is available on my [slides page](/slides/) or on [SpeakerDeck](https://speakerdeck.com/hawkw/creating-a-layer-based-text-editor). I've also added these concepts throughout the notebook post.

---

Gary Bernhardt's ["A Whole New World"](https://www.destroyallsoftware.com/talks/a-whole-new-world) is one of my favourite talks in the field of Computer Science, second only to Guy L. Steele's ["Growing a Language"](https://www.youtube.com/watch?v=_ahvzDzKdB0). All of Mr. Bernhardt's talks are riotously funny, but unlike the light-hearted brevity of ["wat"](https://www.destroyallsoftware.com/talks/wat) ("enough about languages that suck, let's talk about JavaScript") or ["Useing You're Types Good"](https://www.destroyallsoftware.com/talks/useing-youre-types-good) ("types are supposed to make it safe, the program...but when it makes Object it's not safe, which is why I put the fire extinguisher there"), "A Whole New World" uses humor as a vehicle to make some important points about computing as a discipline. 

In "A Whole New World," Bernardt presents an innovative new text editor he claims to have implemented, reveals that implementing this new editor required the implementation of a new terminal emulator, and then finally reveals that both the new text editor and the new terminal emulator are "lies" and that both demos have been rigged. The purpose of this deception is to draw attention to how so many of the core tools that almost every programmer or computer scientist uses, such as text editors, terminal emulators, and even operating systems, almost universally date back to the early days of computing. Bernhardt suggests that these tools and systems deserve to be revisited with modern ideas and technologies, and that the computing industry now focuses on shipping new products as fast as possible, rather than on improving these common tools and infrastructure.

While I strongly agree with the message of "A Whole New World", that's not actually what this blog post is about. Instead, I want to take a moment to talk about one of the features presented in Bernhardt's sham text editor (imaginatively called "`aneditor`"), that I would love to work on implementing, perhaps even as a senior project. `aneditor` is a _layer-based_ editor. This means that information about the source code being edited is stored in separate layers, such as a diff layer, a type-annotation layer, a performance layer, or even a layer showing the result of crash logs from a production environment, which may be overlayed over the code in the editor by entering different modes. 

For example, suppose I'm editing a Java source code file:

<script async class="speakerdeck-embed" data-slide="19" data-id="0c21431d89e54ec89fcda0949c2cfca5" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

I press a button to bring up the `git diff` layer:

<script async class="speakerdeck-embed" data-slide="20" data-id="0c21431d89e54ec89fcda0949c2cfca5" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

I notice that some changes were made, so I want to ensure that all of the changes have been tested. I switch to code coverage mode:

<script async class="speakerdeck-embed" data-slide="21" data-id="0c21431d89e54ec89fcda0949c2cfca5" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

As these examples show, the layer-based paradigm presented by Bernhardt allows a terminal-based text editor to present as much information to the programmer as a full-featured IDE, in a highly extensible and customizeable manner.

All of the information shown in the above examples could be generated by tools external to the editor, such as the `git diff` command, or the user's preferred code coverage tools (including, potentially, an [incremental testing system](/slides/Mod1ModuleLightningTalk-weismanm.pdf) running in the background). Unlike in an integrated development environment (IDE), these are not features of the editor itself. Instead, the information overlaid is the output of small command-line tools which are forked off by the editor. The output of these command-line programs is piped back into the thread associated with that layer, parsed, and displayed in the editor view. 

In contrast to the large, monolithic architecture of "one tool to do everything" followed by most IDEs, the layer-based editor is essentially an extension of the pipes-and-filters architecture. This follows the [Unix philosophy](http://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html) of small, simple tools that do one job efficiently, and [compose well](http://monkey.org/~marius/unix-tools-hints.html) when larger systems are necessary.

In addition, there is room for some more sophisticated functionality not currently provided by commonly used Unix command-line tools. For example, consider a type annotation layer like the following: 

<script async class="speakerdeck-embed" data-slide="22" data-id="0c21431d89e54ec89fcda0949c2cfca5" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>

In this example, the editor forks off a process which performs some static analysis. It traverses the source code and searches for definitions of identifiers, building a type table for the program. Then, whenever a name is referenced, the editor can overlay a line reminding the programmer of the type with which those names are annotated. The types of library functions could be collected as well. This kind of functionality could potentially be very useful, but most programmers would not want to have it displayed all the time, in orer to reduce screen clutter. Therefore, the layer-based display paradigm allows the information to be displayed only when demanded. The editor could pre-process and cache information which takes a long time to collect, so that it may be displayed immediately when that layer is enabled. Providing each layer with its' own thread for performing computations in the background inherently takes advantage of the multi-processor capability of modern computer architectures.

Terminal based text editors popular today, such as `vim(1)` or `emacs(1)`, are highly extensible, and do allow information from analysis of the source code being edited to be presented to the user. However, they aren't designed from the ground up for this layer-based paradigm, so the kind of information overlaying in Bernhardt's fictional `aneditor` unfortunately isn't really possible. A layer-based text editor that functions in the same manner as the fake one from "A Whole New World" would be, in my opinion, an extremely useful tool, and one I'd love to build. 

While it may be a bit too ambitious for a senior project to be completed over the course of a single semester, one of the goals for such a project would be a high level of modoularity. The editor would only provide a common infrastructure for creating layers, leaving the implementation of layers for specific types of information, different programming languages, and interfacing with external tools up to users who desire those components.
